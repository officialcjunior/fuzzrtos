// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rtos_protocol_buffers.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rtos_5fprotocol_5fbuffers_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_rtos_5fprotocol_5fbuffers_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_rtos_5fprotocol_5fbuffers_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rtos_5fprotocol_5fbuffers_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_rtos_5fprotocol_5fbuffers_2eproto;
class EventGroup;
struct EventGroupDefaultTypeInternal;
extern EventGroupDefaultTypeInternal _EventGroup_default_instance_;
class Mutex;
struct MutexDefaultTypeInternal;
extern MutexDefaultTypeInternal _Mutex_default_instance_;
class Option;
struct OptionDefaultTypeInternal;
extern OptionDefaultTypeInternal _Option_default_instance_;
class Queue;
struct QueueDefaultTypeInternal;
extern QueueDefaultTypeInternal _Queue_default_instance_;
class Semaphore;
struct SemaphoreDefaultTypeInternal;
extern SemaphoreDefaultTypeInternal _Semaphore_default_instance_;
class StreamBuffer;
struct StreamBufferDefaultTypeInternal;
extern StreamBufferDefaultTypeInternal _StreamBuffer_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TcpMessage;
struct TcpMessageDefaultTypeInternal;
extern TcpMessageDefaultTypeInternal _TcpMessage_default_instance_;
class input;
struct inputDefaultTypeInternal;
extern inputDefaultTypeInternal _input_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::EventGroup* Arena::CreateMaybeMessage<::EventGroup>(Arena*);
template<> ::Mutex* Arena::CreateMaybeMessage<::Mutex>(Arena*);
template<> ::Option* Arena::CreateMaybeMessage<::Option>(Arena*);
template<> ::Queue* Arena::CreateMaybeMessage<::Queue>(Arena*);
template<> ::Semaphore* Arena::CreateMaybeMessage<::Semaphore>(Arena*);
template<> ::StreamBuffer* Arena::CreateMaybeMessage<::StreamBuffer>(Arena*);
template<> ::Task* Arena::CreateMaybeMessage<::Task>(Arena*);
template<> ::TcpMessage* Arena::CreateMaybeMessage<::TcpMessage>(Arena*);
template<> ::input* Arena::CreateMaybeMessage<::input>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Option final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Option) */ {
 public:
  inline Option() : Option(nullptr) {}
  ~Option() override;
  explicit PROTOBUF_CONSTEXPR Option(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Option(const Option& from);
  Option(Option&& from) noexcept
    : Option() {
    *this = ::std::move(from);
  }

  inline Option& operator=(const Option& from) {
    CopyFrom(from);
    return *this;
  }
  inline Option& operator=(Option&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Option& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kStream = 1,
    kTcp = 2,
    kQueue = 3,
    kTask = 4,
    kSemaphore = 5,
    kMutex = 6,
    kEventGroup = 7,
    VALUE_NOT_SET = 0,
  };

  static inline const Option* internal_default_instance() {
    return reinterpret_cast<const Option*>(
               &_Option_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Option& a, Option& b) {
    a.Swap(&b);
  }
  inline void Swap(Option* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Option* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Option* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Option>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Option& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Option& from) {
    Option::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Option* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Option";
  }
  protected:
  explicit Option(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
    kTcpFieldNumber = 2,
    kQueueFieldNumber = 3,
    kTaskFieldNumber = 4,
    kSemaphoreFieldNumber = 5,
    kMutexFieldNumber = 6,
    kEventGroupFieldNumber = 7,
  };
  // .StreamBuffer stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::StreamBuffer& stream() const;
  PROTOBUF_NODISCARD ::StreamBuffer* release_stream();
  ::StreamBuffer* mutable_stream();
  void set_allocated_stream(::StreamBuffer* stream);
  private:
  const ::StreamBuffer& _internal_stream() const;
  ::StreamBuffer* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::StreamBuffer* stream);
  ::StreamBuffer* unsafe_arena_release_stream();

  // .TcpMessage tcp = 2;
  bool has_tcp() const;
  private:
  bool _internal_has_tcp() const;
  public:
  void clear_tcp();
  const ::TcpMessage& tcp() const;
  PROTOBUF_NODISCARD ::TcpMessage* release_tcp();
  ::TcpMessage* mutable_tcp();
  void set_allocated_tcp(::TcpMessage* tcp);
  private:
  const ::TcpMessage& _internal_tcp() const;
  ::TcpMessage* _internal_mutable_tcp();
  public:
  void unsafe_arena_set_allocated_tcp(
      ::TcpMessage* tcp);
  ::TcpMessage* unsafe_arena_release_tcp();

  // .Queue queue = 3;
  bool has_queue() const;
  private:
  bool _internal_has_queue() const;
  public:
  void clear_queue();
  const ::Queue& queue() const;
  PROTOBUF_NODISCARD ::Queue* release_queue();
  ::Queue* mutable_queue();
  void set_allocated_queue(::Queue* queue);
  private:
  const ::Queue& _internal_queue() const;
  ::Queue* _internal_mutable_queue();
  public:
  void unsafe_arena_set_allocated_queue(
      ::Queue* queue);
  ::Queue* unsafe_arena_release_queue();

  // .Task task = 4;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::Task& task() const;
  PROTOBUF_NODISCARD ::Task* release_task();
  ::Task* mutable_task();
  void set_allocated_task(::Task* task);
  private:
  const ::Task& _internal_task() const;
  ::Task* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::Task* task);
  ::Task* unsafe_arena_release_task();

  // .Semaphore semaphore = 5;
  bool has_semaphore() const;
  private:
  bool _internal_has_semaphore() const;
  public:
  void clear_semaphore();
  const ::Semaphore& semaphore() const;
  PROTOBUF_NODISCARD ::Semaphore* release_semaphore();
  ::Semaphore* mutable_semaphore();
  void set_allocated_semaphore(::Semaphore* semaphore);
  private:
  const ::Semaphore& _internal_semaphore() const;
  ::Semaphore* _internal_mutable_semaphore();
  public:
  void unsafe_arena_set_allocated_semaphore(
      ::Semaphore* semaphore);
  ::Semaphore* unsafe_arena_release_semaphore();

  // .Mutex mutex = 6;
  bool has_mutex() const;
  private:
  bool _internal_has_mutex() const;
  public:
  void clear_mutex();
  const ::Mutex& mutex() const;
  PROTOBUF_NODISCARD ::Mutex* release_mutex();
  ::Mutex* mutable_mutex();
  void set_allocated_mutex(::Mutex* mutex);
  private:
  const ::Mutex& _internal_mutex() const;
  ::Mutex* _internal_mutable_mutex();
  public:
  void unsafe_arena_set_allocated_mutex(
      ::Mutex* mutex);
  ::Mutex* unsafe_arena_release_mutex();

  // .EventGroup event_group = 7;
  bool has_event_group() const;
  private:
  bool _internal_has_event_group() const;
  public:
  void clear_event_group();
  const ::EventGroup& event_group() const;
  PROTOBUF_NODISCARD ::EventGroup* release_event_group();
  ::EventGroup* mutable_event_group();
  void set_allocated_event_group(::EventGroup* event_group);
  private:
  const ::EventGroup& _internal_event_group() const;
  ::EventGroup* _internal_mutable_event_group();
  public:
  void unsafe_arena_set_allocated_event_group(
      ::EventGroup* event_group);
  ::EventGroup* unsafe_arena_release_event_group();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:Option)
 private:
  class _Internal;
  void set_has_stream();
  void set_has_tcp();
  void set_has_queue();
  void set_has_task();
  void set_has_semaphore();
  void set_has_mutex();
  void set_has_event_group();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::StreamBuffer* stream_;
      ::TcpMessage* tcp_;
      ::Queue* queue_;
      ::Task* task_;
      ::Semaphore* semaphore_;
      ::Mutex* mutex_;
      ::EventGroup* event_group_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtos_5fprotocol_5fbuffers_2eproto;
};
// -------------------------------------------------------------------

class input final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:input) */ {
 public:
  inline input() : input(nullptr) {}
  ~input() override;
  explicit PROTOBUF_CONSTEXPR input(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  input(const input& from);
  input(input&& from) noexcept
    : input() {
    *this = ::std::move(from);
  }

  inline input& operator=(const input& from) {
    CopyFrom(from);
    return *this;
  }
  inline input& operator=(input&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const input& default_instance() {
    return *internal_default_instance();
  }
  static inline const input* internal_default_instance() {
    return reinterpret_cast<const input*>(
               &_input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(input& a, input& b) {
    a.Swap(&b);
  }
  inline void Swap(input* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(input* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  input* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<input>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const input& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const input& from) {
    input::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(input* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "input";
  }
  protected:
  explicit input(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqFieldNumber = 1,
  };
  // repeated .Option seq = 1;
  int seq_size() const;
  private:
  int _internal_seq_size() const;
  public:
  void clear_seq();
  ::Option* mutable_seq(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Option >*
      mutable_seq();
  private:
  const ::Option& _internal_seq(int index) const;
  ::Option* _internal_add_seq();
  public:
  const ::Option& seq(int index) const;
  ::Option* add_seq();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Option >&
      seq() const;

  // @@protoc_insertion_point(class_scope:input)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Option > seq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtos_5fprotocol_5fbuffers_2eproto;
};
// -------------------------------------------------------------------

class StreamBuffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StreamBuffer) */ {
 public:
  inline StreamBuffer() : StreamBuffer(nullptr) {}
  ~StreamBuffer() override;
  explicit PROTOBUF_CONSTEXPR StreamBuffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamBuffer(const StreamBuffer& from);
  StreamBuffer(StreamBuffer&& from) noexcept
    : StreamBuffer() {
    *this = ::std::move(from);
  }

  inline StreamBuffer& operator=(const StreamBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamBuffer& operator=(StreamBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamBuffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamBuffer* internal_default_instance() {
    return reinterpret_cast<const StreamBuffer*>(
               &_StreamBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StreamBuffer& a, StreamBuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamBuffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamBuffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamBuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamBuffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamBuffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamBuffer& from) {
    StreamBuffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamBuffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StreamBuffer";
  }
  protected:
  explicit StreamBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBFieldNumber = 2,
    kAFieldNumber = 1,
  };
  // string b = 2;
  void clear_b();
  const std::string& b() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_b(ArgT0&& arg0, ArgT... args);
  std::string* mutable_b();
  PROTOBUF_NODISCARD std::string* release_b();
  void set_allocated_b(std::string* b);
  private:
  const std::string& _internal_b() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_b(const std::string& value);
  std::string* _internal_mutable_b();
  public:

  // uint32 a = 1;
  void clear_a();
  uint32_t a() const;
  void set_a(uint32_t value);
  private:
  uint32_t _internal_a() const;
  void _internal_set_a(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StreamBuffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr b_;
    uint32_t a_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtos_5fprotocol_5fbuffers_2eproto;
};
// -------------------------------------------------------------------

class TcpMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TcpMessage) */ {
 public:
  inline TcpMessage() : TcpMessage(nullptr) {}
  ~TcpMessage() override;
  explicit PROTOBUF_CONSTEXPR TcpMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TcpMessage(const TcpMessage& from);
  TcpMessage(TcpMessage&& from) noexcept
    : TcpMessage() {
    *this = ::std::move(from);
  }

  inline TcpMessage& operator=(const TcpMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TcpMessage& operator=(TcpMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TcpMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TcpMessage* internal_default_instance() {
    return reinterpret_cast<const TcpMessage*>(
               &_TcpMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TcpMessage& a, TcpMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TcpMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TcpMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TcpMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TcpMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TcpMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TcpMessage& from) {
    TcpMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TcpMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TcpMessage";
  }
  protected:
  explicit TcpMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TcpMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtos_5fprotocol_5fbuffers_2eproto;
};
// -------------------------------------------------------------------

class Queue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Queue) */ {
 public:
  inline Queue() : Queue(nullptr) {}
  ~Queue() override;
  explicit PROTOBUF_CONSTEXPR Queue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Queue(const Queue& from);
  Queue(Queue&& from) noexcept
    : Queue() {
    *this = ::std::move(from);
  }

  inline Queue& operator=(const Queue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Queue& operator=(Queue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Queue& default_instance() {
    return *internal_default_instance();
  }
  static inline const Queue* internal_default_instance() {
    return reinterpret_cast<const Queue*>(
               &_Queue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Queue& a, Queue& b) {
    a.Swap(&b);
  }
  inline void Swap(Queue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Queue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Queue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Queue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Queue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Queue& from) {
    Queue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Queue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Queue";
  }
  protected:
  explicit Queue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kItemSizeFieldNumber = 2,
    kLengthFieldNumber = 3,
  };
  // uint32 handle = 1;
  void clear_handle();
  uint32_t handle() const;
  void set_handle(uint32_t value);
  private:
  uint32_t _internal_handle() const;
  void _internal_set_handle(uint32_t value);
  public:

  // uint32 item_size = 2;
  void clear_item_size();
  uint32_t item_size() const;
  void set_item_size(uint32_t value);
  private:
  uint32_t _internal_item_size() const;
  void _internal_set_item_size(uint32_t value);
  public:

  // uint32 length = 3;
  void clear_length();
  uint32_t length() const;
  void set_length(uint32_t value);
  private:
  uint32_t _internal_length() const;
  void _internal_set_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Queue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t handle_;
    uint32_t item_size_;
    uint32_t length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtos_5fprotocol_5fbuffers_2eproto;
};
// -------------------------------------------------------------------

class Task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() override;
  explicit PROTOBUF_CONSTEXPR Task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Task& from) {
    Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kHandleFieldNumber = 1,
    kPriorityFieldNumber = 3,
    kStackSizeFieldNumber = 4,
    kCurrentPriorityFieldNumber = 5,
    kBasePriorityFieldNumber = 6,
    kStackHighWaterMarkFieldNumber = 7,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 handle = 1;
  void clear_handle();
  uint32_t handle() const;
  void set_handle(uint32_t value);
  private:
  uint32_t _internal_handle() const;
  void _internal_set_handle(uint32_t value);
  public:

  // uint32 priority = 3;
  void clear_priority();
  uint32_t priority() const;
  void set_priority(uint32_t value);
  private:
  uint32_t _internal_priority() const;
  void _internal_set_priority(uint32_t value);
  public:

  // uint32 stack_size = 4;
  void clear_stack_size();
  uint32_t stack_size() const;
  void set_stack_size(uint32_t value);
  private:
  uint32_t _internal_stack_size() const;
  void _internal_set_stack_size(uint32_t value);
  public:

  // uint32 current_priority = 5;
  void clear_current_priority();
  uint32_t current_priority() const;
  void set_current_priority(uint32_t value);
  private:
  uint32_t _internal_current_priority() const;
  void _internal_set_current_priority(uint32_t value);
  public:

  // uint32 base_priority = 6;
  void clear_base_priority();
  uint32_t base_priority() const;
  void set_base_priority(uint32_t value);
  private:
  uint32_t _internal_base_priority() const;
  void _internal_set_base_priority(uint32_t value);
  public:

  // uint32 stack_high_water_mark = 7;
  void clear_stack_high_water_mark();
  uint32_t stack_high_water_mark() const;
  void set_stack_high_water_mark(uint32_t value);
  private:
  uint32_t _internal_stack_high_water_mark() const;
  void _internal_set_stack_high_water_mark(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t handle_;
    uint32_t priority_;
    uint32_t stack_size_;
    uint32_t current_priority_;
    uint32_t base_priority_;
    uint32_t stack_high_water_mark_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtos_5fprotocol_5fbuffers_2eproto;
};
// -------------------------------------------------------------------

class Semaphore final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Semaphore) */ {
 public:
  inline Semaphore() : Semaphore(nullptr) {}
  ~Semaphore() override;
  explicit PROTOBUF_CONSTEXPR Semaphore(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Semaphore(const Semaphore& from);
  Semaphore(Semaphore&& from) noexcept
    : Semaphore() {
    *this = ::std::move(from);
  }

  inline Semaphore& operator=(const Semaphore& from) {
    CopyFrom(from);
    return *this;
  }
  inline Semaphore& operator=(Semaphore&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Semaphore& default_instance() {
    return *internal_default_instance();
  }
  static inline const Semaphore* internal_default_instance() {
    return reinterpret_cast<const Semaphore*>(
               &_Semaphore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Semaphore& a, Semaphore& b) {
    a.Swap(&b);
  }
  inline void Swap(Semaphore* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Semaphore* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Semaphore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Semaphore>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Semaphore& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Semaphore& from) {
    Semaphore::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Semaphore* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Semaphore";
  }
  protected:
  explicit Semaphore(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kMaxCountFieldNumber = 2,
    kCurrentCountFieldNumber = 3,
  };
  // uint32 handle = 1;
  void clear_handle();
  uint32_t handle() const;
  void set_handle(uint32_t value);
  private:
  uint32_t _internal_handle() const;
  void _internal_set_handle(uint32_t value);
  public:

  // uint32 max_count = 2;
  void clear_max_count();
  uint32_t max_count() const;
  void set_max_count(uint32_t value);
  private:
  uint32_t _internal_max_count() const;
  void _internal_set_max_count(uint32_t value);
  public:

  // uint32 current_count = 3;
  void clear_current_count();
  uint32_t current_count() const;
  void set_current_count(uint32_t value);
  private:
  uint32_t _internal_current_count() const;
  void _internal_set_current_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Semaphore)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t handle_;
    uint32_t max_count_;
    uint32_t current_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtos_5fprotocol_5fbuffers_2eproto;
};
// -------------------------------------------------------------------

class Mutex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Mutex) */ {
 public:
  inline Mutex() : Mutex(nullptr) {}
  ~Mutex() override;
  explicit PROTOBUF_CONSTEXPR Mutex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mutex(const Mutex& from);
  Mutex(Mutex&& from) noexcept
    : Mutex() {
    *this = ::std::move(from);
  }

  inline Mutex& operator=(const Mutex& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mutex& operator=(Mutex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mutex& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mutex* internal_default_instance() {
    return reinterpret_cast<const Mutex*>(
               &_Mutex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Mutex& a, Mutex& b) {
    a.Swap(&b);
  }
  inline void Swap(Mutex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mutex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mutex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mutex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mutex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mutex& from) {
    Mutex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mutex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mutex";
  }
  protected:
  explicit Mutex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerNameFieldNumber = 3,
    kHandleFieldNumber = 1,
    kRecursionCountFieldNumber = 2,
  };
  // string owner_name = 3;
  void clear_owner_name();
  const std::string& owner_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_name();
  PROTOBUF_NODISCARD std::string* release_owner_name();
  void set_allocated_owner_name(std::string* owner_name);
  private:
  const std::string& _internal_owner_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_name(const std::string& value);
  std::string* _internal_mutable_owner_name();
  public:

  // uint32 handle = 1;
  void clear_handle();
  uint32_t handle() const;
  void set_handle(uint32_t value);
  private:
  uint32_t _internal_handle() const;
  void _internal_set_handle(uint32_t value);
  public:

  // uint32 recursion_count = 2;
  void clear_recursion_count();
  uint32_t recursion_count() const;
  void set_recursion_count(uint32_t value);
  private:
  uint32_t _internal_recursion_count() const;
  void _internal_set_recursion_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Mutex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_name_;
    uint32_t handle_;
    uint32_t recursion_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtos_5fprotocol_5fbuffers_2eproto;
};
// -------------------------------------------------------------------

class EventGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EventGroup) */ {
 public:
  inline EventGroup() : EventGroup(nullptr) {}
  ~EventGroup() override;
  explicit PROTOBUF_CONSTEXPR EventGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventGroup(const EventGroup& from);
  EventGroup(EventGroup&& from) noexcept
    : EventGroup() {
    *this = ::std::move(from);
  }

  inline EventGroup& operator=(const EventGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventGroup& operator=(EventGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventGroup* internal_default_instance() {
    return reinterpret_cast<const EventGroup*>(
               &_EventGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EventGroup& a, EventGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(EventGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventGroup& from) {
    EventGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EventGroup";
  }
  protected:
  explicit EventGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kEventBitsFieldNumber = 2,
  };
  // uint32 handle = 1;
  void clear_handle();
  uint32_t handle() const;
  void set_handle(uint32_t value);
  private:
  uint32_t _internal_handle() const;
  void _internal_set_handle(uint32_t value);
  public:

  // uint32 event_bits = 2;
  void clear_event_bits();
  uint32_t event_bits() const;
  void set_event_bits(uint32_t value);
  private:
  uint32_t _internal_event_bits() const;
  void _internal_set_event_bits(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:EventGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t handle_;
    uint32_t event_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtos_5fprotocol_5fbuffers_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Option

// .StreamBuffer stream = 1;
inline bool Option::_internal_has_stream() const {
  return value_case() == kStream;
}
inline bool Option::has_stream() const {
  return _internal_has_stream();
}
inline void Option::set_has_stream() {
  _impl_._oneof_case_[0] = kStream;
}
inline void Option::clear_stream() {
  if (_internal_has_stream()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.stream_;
    }
    clear_has_value();
  }
}
inline ::StreamBuffer* Option::release_stream() {
  // @@protoc_insertion_point(field_release:Option.stream)
  if (_internal_has_stream()) {
    clear_has_value();
    ::StreamBuffer* temp = _impl_.value_.stream_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StreamBuffer& Option::_internal_stream() const {
  return _internal_has_stream()
      ? *_impl_.value_.stream_
      : reinterpret_cast< ::StreamBuffer&>(::_StreamBuffer_default_instance_);
}
inline const ::StreamBuffer& Option::stream() const {
  // @@protoc_insertion_point(field_get:Option.stream)
  return _internal_stream();
}
inline ::StreamBuffer* Option::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Option.stream)
  if (_internal_has_stream()) {
    clear_has_value();
    ::StreamBuffer* temp = _impl_.value_.stream_;
    _impl_.value_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Option::unsafe_arena_set_allocated_stream(::StreamBuffer* stream) {
  clear_value();
  if (stream) {
    set_has_stream();
    _impl_.value_.stream_ = stream;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Option.stream)
}
inline ::StreamBuffer* Option::_internal_mutable_stream() {
  if (!_internal_has_stream()) {
    clear_value();
    set_has_stream();
    _impl_.value_.stream_ = CreateMaybeMessage< ::StreamBuffer >(GetArenaForAllocation());
  }
  return _impl_.value_.stream_;
}
inline ::StreamBuffer* Option::mutable_stream() {
  ::StreamBuffer* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:Option.stream)
  return _msg;
}

// .TcpMessage tcp = 2;
inline bool Option::_internal_has_tcp() const {
  return value_case() == kTcp;
}
inline bool Option::has_tcp() const {
  return _internal_has_tcp();
}
inline void Option::set_has_tcp() {
  _impl_._oneof_case_[0] = kTcp;
}
inline void Option::clear_tcp() {
  if (_internal_has_tcp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.tcp_;
    }
    clear_has_value();
  }
}
inline ::TcpMessage* Option::release_tcp() {
  // @@protoc_insertion_point(field_release:Option.tcp)
  if (_internal_has_tcp()) {
    clear_has_value();
    ::TcpMessage* temp = _impl_.value_.tcp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.tcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TcpMessage& Option::_internal_tcp() const {
  return _internal_has_tcp()
      ? *_impl_.value_.tcp_
      : reinterpret_cast< ::TcpMessage&>(::_TcpMessage_default_instance_);
}
inline const ::TcpMessage& Option::tcp() const {
  // @@protoc_insertion_point(field_get:Option.tcp)
  return _internal_tcp();
}
inline ::TcpMessage* Option::unsafe_arena_release_tcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Option.tcp)
  if (_internal_has_tcp()) {
    clear_has_value();
    ::TcpMessage* temp = _impl_.value_.tcp_;
    _impl_.value_.tcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Option::unsafe_arena_set_allocated_tcp(::TcpMessage* tcp) {
  clear_value();
  if (tcp) {
    set_has_tcp();
    _impl_.value_.tcp_ = tcp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Option.tcp)
}
inline ::TcpMessage* Option::_internal_mutable_tcp() {
  if (!_internal_has_tcp()) {
    clear_value();
    set_has_tcp();
    _impl_.value_.tcp_ = CreateMaybeMessage< ::TcpMessage >(GetArenaForAllocation());
  }
  return _impl_.value_.tcp_;
}
inline ::TcpMessage* Option::mutable_tcp() {
  ::TcpMessage* _msg = _internal_mutable_tcp();
  // @@protoc_insertion_point(field_mutable:Option.tcp)
  return _msg;
}

// .Queue queue = 3;
inline bool Option::_internal_has_queue() const {
  return value_case() == kQueue;
}
inline bool Option::has_queue() const {
  return _internal_has_queue();
}
inline void Option::set_has_queue() {
  _impl_._oneof_case_[0] = kQueue;
}
inline void Option::clear_queue() {
  if (_internal_has_queue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.queue_;
    }
    clear_has_value();
  }
}
inline ::Queue* Option::release_queue() {
  // @@protoc_insertion_point(field_release:Option.queue)
  if (_internal_has_queue()) {
    clear_has_value();
    ::Queue* temp = _impl_.value_.queue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.queue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Queue& Option::_internal_queue() const {
  return _internal_has_queue()
      ? *_impl_.value_.queue_
      : reinterpret_cast< ::Queue&>(::_Queue_default_instance_);
}
inline const ::Queue& Option::queue() const {
  // @@protoc_insertion_point(field_get:Option.queue)
  return _internal_queue();
}
inline ::Queue* Option::unsafe_arena_release_queue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Option.queue)
  if (_internal_has_queue()) {
    clear_has_value();
    ::Queue* temp = _impl_.value_.queue_;
    _impl_.value_.queue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Option::unsafe_arena_set_allocated_queue(::Queue* queue) {
  clear_value();
  if (queue) {
    set_has_queue();
    _impl_.value_.queue_ = queue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Option.queue)
}
inline ::Queue* Option::_internal_mutable_queue() {
  if (!_internal_has_queue()) {
    clear_value();
    set_has_queue();
    _impl_.value_.queue_ = CreateMaybeMessage< ::Queue >(GetArenaForAllocation());
  }
  return _impl_.value_.queue_;
}
inline ::Queue* Option::mutable_queue() {
  ::Queue* _msg = _internal_mutable_queue();
  // @@protoc_insertion_point(field_mutable:Option.queue)
  return _msg;
}

// .Task task = 4;
inline bool Option::_internal_has_task() const {
  return value_case() == kTask;
}
inline bool Option::has_task() const {
  return _internal_has_task();
}
inline void Option::set_has_task() {
  _impl_._oneof_case_[0] = kTask;
}
inline void Option::clear_task() {
  if (_internal_has_task()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.task_;
    }
    clear_has_value();
  }
}
inline ::Task* Option::release_task() {
  // @@protoc_insertion_point(field_release:Option.task)
  if (_internal_has_task()) {
    clear_has_value();
    ::Task* temp = _impl_.value_.task_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.task_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Task& Option::_internal_task() const {
  return _internal_has_task()
      ? *_impl_.value_.task_
      : reinterpret_cast< ::Task&>(::_Task_default_instance_);
}
inline const ::Task& Option::task() const {
  // @@protoc_insertion_point(field_get:Option.task)
  return _internal_task();
}
inline ::Task* Option::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Option.task)
  if (_internal_has_task()) {
    clear_has_value();
    ::Task* temp = _impl_.value_.task_;
    _impl_.value_.task_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Option::unsafe_arena_set_allocated_task(::Task* task) {
  clear_value();
  if (task) {
    set_has_task();
    _impl_.value_.task_ = task;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Option.task)
}
inline ::Task* Option::_internal_mutable_task() {
  if (!_internal_has_task()) {
    clear_value();
    set_has_task();
    _impl_.value_.task_ = CreateMaybeMessage< ::Task >(GetArenaForAllocation());
  }
  return _impl_.value_.task_;
}
inline ::Task* Option::mutable_task() {
  ::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:Option.task)
  return _msg;
}

// .Semaphore semaphore = 5;
inline bool Option::_internal_has_semaphore() const {
  return value_case() == kSemaphore;
}
inline bool Option::has_semaphore() const {
  return _internal_has_semaphore();
}
inline void Option::set_has_semaphore() {
  _impl_._oneof_case_[0] = kSemaphore;
}
inline void Option::clear_semaphore() {
  if (_internal_has_semaphore()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.semaphore_;
    }
    clear_has_value();
  }
}
inline ::Semaphore* Option::release_semaphore() {
  // @@protoc_insertion_point(field_release:Option.semaphore)
  if (_internal_has_semaphore()) {
    clear_has_value();
    ::Semaphore* temp = _impl_.value_.semaphore_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.semaphore_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Semaphore& Option::_internal_semaphore() const {
  return _internal_has_semaphore()
      ? *_impl_.value_.semaphore_
      : reinterpret_cast< ::Semaphore&>(::_Semaphore_default_instance_);
}
inline const ::Semaphore& Option::semaphore() const {
  // @@protoc_insertion_point(field_get:Option.semaphore)
  return _internal_semaphore();
}
inline ::Semaphore* Option::unsafe_arena_release_semaphore() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Option.semaphore)
  if (_internal_has_semaphore()) {
    clear_has_value();
    ::Semaphore* temp = _impl_.value_.semaphore_;
    _impl_.value_.semaphore_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Option::unsafe_arena_set_allocated_semaphore(::Semaphore* semaphore) {
  clear_value();
  if (semaphore) {
    set_has_semaphore();
    _impl_.value_.semaphore_ = semaphore;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Option.semaphore)
}
inline ::Semaphore* Option::_internal_mutable_semaphore() {
  if (!_internal_has_semaphore()) {
    clear_value();
    set_has_semaphore();
    _impl_.value_.semaphore_ = CreateMaybeMessage< ::Semaphore >(GetArenaForAllocation());
  }
  return _impl_.value_.semaphore_;
}
inline ::Semaphore* Option::mutable_semaphore() {
  ::Semaphore* _msg = _internal_mutable_semaphore();
  // @@protoc_insertion_point(field_mutable:Option.semaphore)
  return _msg;
}

// .Mutex mutex = 6;
inline bool Option::_internal_has_mutex() const {
  return value_case() == kMutex;
}
inline bool Option::has_mutex() const {
  return _internal_has_mutex();
}
inline void Option::set_has_mutex() {
  _impl_._oneof_case_[0] = kMutex;
}
inline void Option::clear_mutex() {
  if (_internal_has_mutex()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.mutex_;
    }
    clear_has_value();
  }
}
inline ::Mutex* Option::release_mutex() {
  // @@protoc_insertion_point(field_release:Option.mutex)
  if (_internal_has_mutex()) {
    clear_has_value();
    ::Mutex* temp = _impl_.value_.mutex_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.mutex_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Mutex& Option::_internal_mutex() const {
  return _internal_has_mutex()
      ? *_impl_.value_.mutex_
      : reinterpret_cast< ::Mutex&>(::_Mutex_default_instance_);
}
inline const ::Mutex& Option::mutex() const {
  // @@protoc_insertion_point(field_get:Option.mutex)
  return _internal_mutex();
}
inline ::Mutex* Option::unsafe_arena_release_mutex() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Option.mutex)
  if (_internal_has_mutex()) {
    clear_has_value();
    ::Mutex* temp = _impl_.value_.mutex_;
    _impl_.value_.mutex_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Option::unsafe_arena_set_allocated_mutex(::Mutex* mutex) {
  clear_value();
  if (mutex) {
    set_has_mutex();
    _impl_.value_.mutex_ = mutex;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Option.mutex)
}
inline ::Mutex* Option::_internal_mutable_mutex() {
  if (!_internal_has_mutex()) {
    clear_value();
    set_has_mutex();
    _impl_.value_.mutex_ = CreateMaybeMessage< ::Mutex >(GetArenaForAllocation());
  }
  return _impl_.value_.mutex_;
}
inline ::Mutex* Option::mutable_mutex() {
  ::Mutex* _msg = _internal_mutable_mutex();
  // @@protoc_insertion_point(field_mutable:Option.mutex)
  return _msg;
}

// .EventGroup event_group = 7;
inline bool Option::_internal_has_event_group() const {
  return value_case() == kEventGroup;
}
inline bool Option::has_event_group() const {
  return _internal_has_event_group();
}
inline void Option::set_has_event_group() {
  _impl_._oneof_case_[0] = kEventGroup;
}
inline void Option::clear_event_group() {
  if (_internal_has_event_group()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.event_group_;
    }
    clear_has_value();
  }
}
inline ::EventGroup* Option::release_event_group() {
  // @@protoc_insertion_point(field_release:Option.event_group)
  if (_internal_has_event_group()) {
    clear_has_value();
    ::EventGroup* temp = _impl_.value_.event_group_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::EventGroup& Option::_internal_event_group() const {
  return _internal_has_event_group()
      ? *_impl_.value_.event_group_
      : reinterpret_cast< ::EventGroup&>(::_EventGroup_default_instance_);
}
inline const ::EventGroup& Option::event_group() const {
  // @@protoc_insertion_point(field_get:Option.event_group)
  return _internal_event_group();
}
inline ::EventGroup* Option::unsafe_arena_release_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Option.event_group)
  if (_internal_has_event_group()) {
    clear_has_value();
    ::EventGroup* temp = _impl_.value_.event_group_;
    _impl_.value_.event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Option::unsafe_arena_set_allocated_event_group(::EventGroup* event_group) {
  clear_value();
  if (event_group) {
    set_has_event_group();
    _impl_.value_.event_group_ = event_group;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Option.event_group)
}
inline ::EventGroup* Option::_internal_mutable_event_group() {
  if (!_internal_has_event_group()) {
    clear_value();
    set_has_event_group();
    _impl_.value_.event_group_ = CreateMaybeMessage< ::EventGroup >(GetArenaForAllocation());
  }
  return _impl_.value_.event_group_;
}
inline ::EventGroup* Option::mutable_event_group() {
  ::EventGroup* _msg = _internal_mutable_event_group();
  // @@protoc_insertion_point(field_mutable:Option.event_group)
  return _msg;
}

inline bool Option::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Option::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Option::ValueCase Option::value_case() const {
  return Option::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// input

// repeated .Option seq = 1;
inline int input::_internal_seq_size() const {
  return _impl_.seq_.size();
}
inline int input::seq_size() const {
  return _internal_seq_size();
}
inline void input::clear_seq() {
  _impl_.seq_.Clear();
}
inline ::Option* input::mutable_seq(int index) {
  // @@protoc_insertion_point(field_mutable:input.seq)
  return _impl_.seq_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Option >*
input::mutable_seq() {
  // @@protoc_insertion_point(field_mutable_list:input.seq)
  return &_impl_.seq_;
}
inline const ::Option& input::_internal_seq(int index) const {
  return _impl_.seq_.Get(index);
}
inline const ::Option& input::seq(int index) const {
  // @@protoc_insertion_point(field_get:input.seq)
  return _internal_seq(index);
}
inline ::Option* input::_internal_add_seq() {
  return _impl_.seq_.Add();
}
inline ::Option* input::add_seq() {
  ::Option* _add = _internal_add_seq();
  // @@protoc_insertion_point(field_add:input.seq)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Option >&
input::seq() const {
  // @@protoc_insertion_point(field_list:input.seq)
  return _impl_.seq_;
}

// -------------------------------------------------------------------

// StreamBuffer

// uint32 a = 1;
inline void StreamBuffer::clear_a() {
  _impl_.a_ = 0u;
}
inline uint32_t StreamBuffer::_internal_a() const {
  return _impl_.a_;
}
inline uint32_t StreamBuffer::a() const {
  // @@protoc_insertion_point(field_get:StreamBuffer.a)
  return _internal_a();
}
inline void StreamBuffer::_internal_set_a(uint32_t value) {
  
  _impl_.a_ = value;
}
inline void StreamBuffer::set_a(uint32_t value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:StreamBuffer.a)
}

// string b = 2;
inline void StreamBuffer::clear_b() {
  _impl_.b_.ClearToEmpty();
}
inline const std::string& StreamBuffer::b() const {
  // @@protoc_insertion_point(field_get:StreamBuffer.b)
  return _internal_b();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamBuffer::set_b(ArgT0&& arg0, ArgT... args) {
 
 _impl_.b_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StreamBuffer.b)
}
inline std::string* StreamBuffer::mutable_b() {
  std::string* _s = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:StreamBuffer.b)
  return _s;
}
inline const std::string& StreamBuffer::_internal_b() const {
  return _impl_.b_.Get();
}
inline void StreamBuffer::_internal_set_b(const std::string& value) {
  
  _impl_.b_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamBuffer::_internal_mutable_b() {
  
  return _impl_.b_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamBuffer::release_b() {
  // @@protoc_insertion_point(field_release:StreamBuffer.b)
  return _impl_.b_.Release();
}
inline void StreamBuffer::set_allocated_b(std::string* b) {
  if (b != nullptr) {
    
  } else {
    
  }
  _impl_.b_.SetAllocated(b, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.b_.IsDefault()) {
    _impl_.b_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StreamBuffer.b)
}

// -------------------------------------------------------------------

// TcpMessage

// int32 id = 1;
inline void TcpMessage::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t TcpMessage::_internal_id() const {
  return _impl_.id_;
}
inline int32_t TcpMessage::id() const {
  // @@protoc_insertion_point(field_get:TcpMessage.id)
  return _internal_id();
}
inline void TcpMessage::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void TcpMessage::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:TcpMessage.id)
}

// string payload = 2;
inline void TcpMessage::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& TcpMessage::payload() const {
  // @@protoc_insertion_point(field_get:TcpMessage.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TcpMessage::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TcpMessage.payload)
}
inline std::string* TcpMessage::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:TcpMessage.payload)
  return _s;
}
inline const std::string& TcpMessage::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void TcpMessage::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* TcpMessage::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* TcpMessage::release_payload() {
  // @@protoc_insertion_point(field_release:TcpMessage.payload)
  return _impl_.payload_.Release();
}
inline void TcpMessage::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TcpMessage.payload)
}

// -------------------------------------------------------------------

// Queue

// uint32 handle = 1;
inline void Queue::clear_handle() {
  _impl_.handle_ = 0u;
}
inline uint32_t Queue::_internal_handle() const {
  return _impl_.handle_;
}
inline uint32_t Queue::handle() const {
  // @@protoc_insertion_point(field_get:Queue.handle)
  return _internal_handle();
}
inline void Queue::_internal_set_handle(uint32_t value) {
  
  _impl_.handle_ = value;
}
inline void Queue::set_handle(uint32_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:Queue.handle)
}

// uint32 item_size = 2;
inline void Queue::clear_item_size() {
  _impl_.item_size_ = 0u;
}
inline uint32_t Queue::_internal_item_size() const {
  return _impl_.item_size_;
}
inline uint32_t Queue::item_size() const {
  // @@protoc_insertion_point(field_get:Queue.item_size)
  return _internal_item_size();
}
inline void Queue::_internal_set_item_size(uint32_t value) {
  
  _impl_.item_size_ = value;
}
inline void Queue::set_item_size(uint32_t value) {
  _internal_set_item_size(value);
  // @@protoc_insertion_point(field_set:Queue.item_size)
}

// uint32 length = 3;
inline void Queue::clear_length() {
  _impl_.length_ = 0u;
}
inline uint32_t Queue::_internal_length() const {
  return _impl_.length_;
}
inline uint32_t Queue::length() const {
  // @@protoc_insertion_point(field_get:Queue.length)
  return _internal_length();
}
inline void Queue::_internal_set_length(uint32_t value) {
  
  _impl_.length_ = value;
}
inline void Queue::set_length(uint32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:Queue.length)
}

// -------------------------------------------------------------------

// Task

// uint32 handle = 1;
inline void Task::clear_handle() {
  _impl_.handle_ = 0u;
}
inline uint32_t Task::_internal_handle() const {
  return _impl_.handle_;
}
inline uint32_t Task::handle() const {
  // @@protoc_insertion_point(field_get:Task.handle)
  return _internal_handle();
}
inline void Task::_internal_set_handle(uint32_t value) {
  
  _impl_.handle_ = value;
}
inline void Task::set_handle(uint32_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:Task.handle)
}

// string name = 2;
inline void Task::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Task::name() const {
  // @@protoc_insertion_point(field_get:Task.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Task::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Task.name)
}
inline std::string* Task::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Task.name)
  return _s;
}
inline const std::string& Task::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Task::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Task::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Task::release_name() {
  // @@protoc_insertion_point(field_release:Task.name)
  return _impl_.name_.Release();
}
inline void Task::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Task.name)
}

// uint32 priority = 3;
inline void Task::clear_priority() {
  _impl_.priority_ = 0u;
}
inline uint32_t Task::_internal_priority() const {
  return _impl_.priority_;
}
inline uint32_t Task::priority() const {
  // @@protoc_insertion_point(field_get:Task.priority)
  return _internal_priority();
}
inline void Task::_internal_set_priority(uint32_t value) {
  
  _impl_.priority_ = value;
}
inline void Task::set_priority(uint32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:Task.priority)
}

// uint32 stack_size = 4;
inline void Task::clear_stack_size() {
  _impl_.stack_size_ = 0u;
}
inline uint32_t Task::_internal_stack_size() const {
  return _impl_.stack_size_;
}
inline uint32_t Task::stack_size() const {
  // @@protoc_insertion_point(field_get:Task.stack_size)
  return _internal_stack_size();
}
inline void Task::_internal_set_stack_size(uint32_t value) {
  
  _impl_.stack_size_ = value;
}
inline void Task::set_stack_size(uint32_t value) {
  _internal_set_stack_size(value);
  // @@protoc_insertion_point(field_set:Task.stack_size)
}

// uint32 current_priority = 5;
inline void Task::clear_current_priority() {
  _impl_.current_priority_ = 0u;
}
inline uint32_t Task::_internal_current_priority() const {
  return _impl_.current_priority_;
}
inline uint32_t Task::current_priority() const {
  // @@protoc_insertion_point(field_get:Task.current_priority)
  return _internal_current_priority();
}
inline void Task::_internal_set_current_priority(uint32_t value) {
  
  _impl_.current_priority_ = value;
}
inline void Task::set_current_priority(uint32_t value) {
  _internal_set_current_priority(value);
  // @@protoc_insertion_point(field_set:Task.current_priority)
}

// uint32 base_priority = 6;
inline void Task::clear_base_priority() {
  _impl_.base_priority_ = 0u;
}
inline uint32_t Task::_internal_base_priority() const {
  return _impl_.base_priority_;
}
inline uint32_t Task::base_priority() const {
  // @@protoc_insertion_point(field_get:Task.base_priority)
  return _internal_base_priority();
}
inline void Task::_internal_set_base_priority(uint32_t value) {
  
  _impl_.base_priority_ = value;
}
inline void Task::set_base_priority(uint32_t value) {
  _internal_set_base_priority(value);
  // @@protoc_insertion_point(field_set:Task.base_priority)
}

// uint32 stack_high_water_mark = 7;
inline void Task::clear_stack_high_water_mark() {
  _impl_.stack_high_water_mark_ = 0u;
}
inline uint32_t Task::_internal_stack_high_water_mark() const {
  return _impl_.stack_high_water_mark_;
}
inline uint32_t Task::stack_high_water_mark() const {
  // @@protoc_insertion_point(field_get:Task.stack_high_water_mark)
  return _internal_stack_high_water_mark();
}
inline void Task::_internal_set_stack_high_water_mark(uint32_t value) {
  
  _impl_.stack_high_water_mark_ = value;
}
inline void Task::set_stack_high_water_mark(uint32_t value) {
  _internal_set_stack_high_water_mark(value);
  // @@protoc_insertion_point(field_set:Task.stack_high_water_mark)
}

// -------------------------------------------------------------------

// Semaphore

// uint32 handle = 1;
inline void Semaphore::clear_handle() {
  _impl_.handle_ = 0u;
}
inline uint32_t Semaphore::_internal_handle() const {
  return _impl_.handle_;
}
inline uint32_t Semaphore::handle() const {
  // @@protoc_insertion_point(field_get:Semaphore.handle)
  return _internal_handle();
}
inline void Semaphore::_internal_set_handle(uint32_t value) {
  
  _impl_.handle_ = value;
}
inline void Semaphore::set_handle(uint32_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:Semaphore.handle)
}

// uint32 max_count = 2;
inline void Semaphore::clear_max_count() {
  _impl_.max_count_ = 0u;
}
inline uint32_t Semaphore::_internal_max_count() const {
  return _impl_.max_count_;
}
inline uint32_t Semaphore::max_count() const {
  // @@protoc_insertion_point(field_get:Semaphore.max_count)
  return _internal_max_count();
}
inline void Semaphore::_internal_set_max_count(uint32_t value) {
  
  _impl_.max_count_ = value;
}
inline void Semaphore::set_max_count(uint32_t value) {
  _internal_set_max_count(value);
  // @@protoc_insertion_point(field_set:Semaphore.max_count)
}

// uint32 current_count = 3;
inline void Semaphore::clear_current_count() {
  _impl_.current_count_ = 0u;
}
inline uint32_t Semaphore::_internal_current_count() const {
  return _impl_.current_count_;
}
inline uint32_t Semaphore::current_count() const {
  // @@protoc_insertion_point(field_get:Semaphore.current_count)
  return _internal_current_count();
}
inline void Semaphore::_internal_set_current_count(uint32_t value) {
  
  _impl_.current_count_ = value;
}
inline void Semaphore::set_current_count(uint32_t value) {
  _internal_set_current_count(value);
  // @@protoc_insertion_point(field_set:Semaphore.current_count)
}

// -------------------------------------------------------------------

// Mutex

// uint32 handle = 1;
inline void Mutex::clear_handle() {
  _impl_.handle_ = 0u;
}
inline uint32_t Mutex::_internal_handle() const {
  return _impl_.handle_;
}
inline uint32_t Mutex::handle() const {
  // @@protoc_insertion_point(field_get:Mutex.handle)
  return _internal_handle();
}
inline void Mutex::_internal_set_handle(uint32_t value) {
  
  _impl_.handle_ = value;
}
inline void Mutex::set_handle(uint32_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:Mutex.handle)
}

// uint32 recursion_count = 2;
inline void Mutex::clear_recursion_count() {
  _impl_.recursion_count_ = 0u;
}
inline uint32_t Mutex::_internal_recursion_count() const {
  return _impl_.recursion_count_;
}
inline uint32_t Mutex::recursion_count() const {
  // @@protoc_insertion_point(field_get:Mutex.recursion_count)
  return _internal_recursion_count();
}
inline void Mutex::_internal_set_recursion_count(uint32_t value) {
  
  _impl_.recursion_count_ = value;
}
inline void Mutex::set_recursion_count(uint32_t value) {
  _internal_set_recursion_count(value);
  // @@protoc_insertion_point(field_set:Mutex.recursion_count)
}

// string owner_name = 3;
inline void Mutex::clear_owner_name() {
  _impl_.owner_name_.ClearToEmpty();
}
inline const std::string& Mutex::owner_name() const {
  // @@protoc_insertion_point(field_get:Mutex.owner_name)
  return _internal_owner_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mutex::set_owner_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Mutex.owner_name)
}
inline std::string* Mutex::mutable_owner_name() {
  std::string* _s = _internal_mutable_owner_name();
  // @@protoc_insertion_point(field_mutable:Mutex.owner_name)
  return _s;
}
inline const std::string& Mutex::_internal_owner_name() const {
  return _impl_.owner_name_.Get();
}
inline void Mutex::_internal_set_owner_name(const std::string& value) {
  
  _impl_.owner_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Mutex::_internal_mutable_owner_name() {
  
  return _impl_.owner_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Mutex::release_owner_name() {
  // @@protoc_insertion_point(field_release:Mutex.owner_name)
  return _impl_.owner_name_.Release();
}
inline void Mutex::set_allocated_owner_name(std::string* owner_name) {
  if (owner_name != nullptr) {
    
  } else {
    
  }
  _impl_.owner_name_.SetAllocated(owner_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_name_.IsDefault()) {
    _impl_.owner_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Mutex.owner_name)
}

// -------------------------------------------------------------------

// EventGroup

// uint32 handle = 1;
inline void EventGroup::clear_handle() {
  _impl_.handle_ = 0u;
}
inline uint32_t EventGroup::_internal_handle() const {
  return _impl_.handle_;
}
inline uint32_t EventGroup::handle() const {
  // @@protoc_insertion_point(field_get:EventGroup.handle)
  return _internal_handle();
}
inline void EventGroup::_internal_set_handle(uint32_t value) {
  
  _impl_.handle_ = value;
}
inline void EventGroup::set_handle(uint32_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:EventGroup.handle)
}

// uint32 event_bits = 2;
inline void EventGroup::clear_event_bits() {
  _impl_.event_bits_ = 0u;
}
inline uint32_t EventGroup::_internal_event_bits() const {
  return _impl_.event_bits_;
}
inline uint32_t EventGroup::event_bits() const {
  // @@protoc_insertion_point(field_get:EventGroup.event_bits)
  return _internal_event_bits();
}
inline void EventGroup::_internal_set_event_bits(uint32_t value) {
  
  _impl_.event_bits_ = value;
}
inline void EventGroup::set_event_bits(uint32_t value) {
  _internal_set_event_bits(value);
  // @@protoc_insertion_point(field_set:EventGroup.event_bits)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_rtos_5fprotocol_5fbuffers_2eproto
